start: (_NEWLINE | stmt)*
?stmt: simple_stmt | statedef
?inner_stmt : simple_stmt| match_stmt | for_stmt | if_stmt
simple_stmt: small_stmt _NEWLINE

?small_stmt : pass_expr | branch_expr | full_expr |assign_expr |break_stmt|continue_stmt
_suite:  _NEWLINE _INDENT inner_stmt+ _DEDENT

statedef: "state" NAME  ":" _suite
match_stmt : "match" full_expr ":" _NEWLINE _INDENT case_stmt+ default_stmt? _DEDENT
case_stmt:  full_expr "=>" _NEWLINE _INDENT inner_stmt+ _DEDENT
default_stmt : "default" "=>" _NEWLINE _INDENT inner_stmt+ _DEDENT
for_stmt : "for" NAME "=" full_expr "to" full_expr  ":"  _NEWLINE _INDENT inner_stmt+ _DEDENT
if_stmt : "if" full_expr ":" _NEWLINE _INDENT inner_stmt+ _DEDENT "else" ":" _NEWLINE _INDENT inner_stmt+ _DEDENT
pass_expr : "pass"
branch_expr : "branch" NAME
continue_stmt : "continue"
break_stmt : "break"
assign_expr : NAME assign_op full_expr
parameters: full_expr ("," full_expr)*

?full_expr: or_test | conditional_expr
conditional_expr:or_test "?" or_test ":" full_expr
?or_test: and_test ("or" and_test)*
?and_test: not_test ("and" not_test)*
?not_test: "not" not_test
         | compare_expr
?compare_expr: arith_expr (comp_op arith_expr)*
?arith_expr : op (add_op op)*
?op : atom (mul_op op)*
!comp_op : "<"|">"|"=="|">="|"<="|"!="
!add_op : "+"|"-"
!mul_op : "*"|"/"|"//"|"%"
!assign_op : "="
?atom : "(" full_expr ")"
          | SIGNED_FLOAT
          | SIGNED_INT
          | STR
          | NAME
          | "none" -> none
          | "true" -> true
          | "false" -> false
          | NAME "(" [parameters] ")" -> funcall
STR : (STRING | LONG_STRING)+

CN_ZH_LETTER: /[u"\u4e00-\u9fa5"]/
LETTER: UCASE_LETTER | LCASE_LETTER | CN_ZH_LETTER
NAME : ("_"|LETTER) ("_"|LETTER|DIGIT)*
SIGNED_FLOAT : ["+"|"-"]FLOAT
SIGNED_INT : ["+"|"-"]INT
%import common.WS_INLINE
%import common.FLOAT -> FLOAT
%import common.DIGIT -> DIGIT
%import common.LCASE_LETTER -> LCASE_LETTER
%import common.UCASE_LETTER -> UCASE_LETTER
%import common.INT -> INT

%declare _INDENT _DEDENT
%ignore WS_INLINE
%ignore COMMENT

// REG :  "/" STRING "/"
COMMENT: /#[^\n]*/
_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+
STRING: /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
LONG_STRING: /[ubf]?r?(""".*?(?<!\\)(\\\\)*?"""|'''.*?(?<!\\)(\\\\)*?''')/is
