
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>lark.lark &#8212; samoyed  文档</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/translations.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">samoyed  文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">模块代码</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">lark.lark</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>lark.lark 源代码</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">pickle</span><span class="o">,</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">IO</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Collection</span>
<span class="p">)</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.parsers.lalr_interactive_parser</span> <span class="kn">import</span> <span class="n">InteractiveParser</span>
    <span class="kn">from</span> <span class="nn">.visitors</span> <span class="kn">import</span> <span class="n">Transformer</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>
        
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">ConfigurationError</span><span class="p">,</span> <span class="n">assert_config</span><span class="p">,</span> <span class="n">UnexpectedInput</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">Serialize</span><span class="p">,</span> <span class="n">SerializeMemoizer</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">isascii</span><span class="p">,</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">.load_grammar</span> <span class="kn">import</span> <span class="n">load_grammar</span><span class="p">,</span> <span class="n">FromPackageLoader</span><span class="p">,</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">verify_used_files</span><span class="p">,</span> <span class="n">PackageResource</span>
<span class="kn">from</span> <span class="nn">.tree</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="kn">from</span> <span class="nn">.common</span> <span class="kn">import</span> <span class="n">LexerConf</span><span class="p">,</span> <span class="n">ParserConf</span>

<span class="kn">from</span> <span class="nn">.lexer</span> <span class="kn">import</span> <span class="n">Lexer</span><span class="p">,</span> <span class="n">BasicLexer</span><span class="p">,</span> <span class="n">TerminalDef</span><span class="p">,</span> <span class="n">LexerThread</span><span class="p">,</span> <span class="n">Token</span>
<span class="kn">from</span> <span class="nn">.parse_tree_builder</span> <span class="kn">import</span> <span class="n">ParseTreeBuilder</span>
<span class="kn">from</span> <span class="nn">.parser_frontends</span> <span class="kn">import</span> <span class="n">get_frontend</span><span class="p">,</span> <span class="n">_get_lexer_callbacks</span>
<span class="kn">from</span> <span class="nn">.grammar</span> <span class="kn">import</span> <span class="n">Rule</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">regex</span>  <span class="c1"># type: ignore</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1">###{standalone</span>


<span class="k">class</span> <span class="nc">PostLex</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Token</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Token</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">stream</span>

    <span class="n">always_accept</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>

<span class="k">class</span> <span class="nc">LarkOptions</span><span class="p">(</span><span class="n">Serialize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Specifies the options for Lark</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">start</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">transformer</span><span class="p">:</span> <span class="s1">&#39;Optional[Transformer]&#39;</span>
    <span class="n">propagate_positions</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="n">maybe_placeholders</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">cache</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
    <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">g_regex_flags</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">keep_all_tokens</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">tree_class</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">parser</span><span class="p">:</span> <span class="s1">&#39;Literal[&quot;earley&quot;, &quot;lalr&quot;, &quot;cyk&quot;, &quot;auto&quot;]&#39;</span>
    <span class="n">lexer</span><span class="p">:</span> <span class="s1">&#39;Union[Literal[&quot;auto&quot;, &quot;basic&quot;, &quot;contextual&quot;, &quot;dynamic&quot;, &quot;dynamic_complete&quot;], Type[Lexer]]&#39;</span>
    <span class="n">ambiguity</span><span class="p">:</span> <span class="s1">&#39;Literal[&quot;auto&quot;, &quot;resolve&quot;, &quot;explicit&quot;, &quot;forest&quot;]&#39;</span>
    <span class="n">postlex</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PostLex</span><span class="p">]</span>
    <span class="n">priority</span><span class="p">:</span> <span class="s1">&#39;Optional[Literal[&quot;auto&quot;, &quot;normal&quot;, &quot;invert&quot;]]&#39;</span>
    <span class="n">lexer_callbacks</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Token</span><span class="p">],</span> <span class="n">Token</span><span class="p">]]</span>
    <span class="n">use_bytes</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">edit_terminals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">TerminalDef</span><span class="p">],</span> <span class="n">TerminalDef</span><span class="p">]]</span>
    <span class="n">import_paths</span><span class="p">:</span> <span class="s1">&#39;List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]&#39;</span>
    <span class="n">source_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="n">OPTIONS_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    **===  General Options  ===**</span>

<span class="s2">    start</span>
<span class="s2">            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: &quot;start&quot;)</span>
<span class="s2">    debug</span>
<span class="s2">            Display debug information and extra warnings. Use only when debugging (Default: ``False``)</span>
<span class="s2">            When used with Earley, it generates a forest graph as &quot;sppf.png&quot;, if &#39;dot&#39; is installed.</span>
<span class="s2">    transformer</span>
<span class="s2">            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)</span>
<span class="s2">    propagate_positions</span>
<span class="s2">            Propagates (line, column, end_line, end_column) attributes into all tree branches.</span>
<span class="s2">            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.</span>
<span class="s2">    maybe_placeholders</span>
<span class="s2">            When ``True``, the ``[]`` operator returns ``None`` when not matched.</span>
<span class="s2">            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.</span>
<span class="s2">            (default= ``True``)</span>
<span class="s2">    cache</span>
<span class="s2">            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.</span>

<span class="s2">            - When ``False``, does nothing (default)</span>
<span class="s2">            - When ``True``, caches to a temporary file in the local directory</span>
<span class="s2">            - When given a string, caches to the path pointed by the string</span>
<span class="s2">    regex</span>
<span class="s2">            When True, uses the ``regex`` module instead of the stdlib ``re``.</span>
<span class="s2">    g_regex_flags</span>
<span class="s2">            Flags that are applied to all terminals (both regex and strings)</span>
<span class="s2">    keep_all_tokens</span>
<span class="s2">            Prevent the tree builder from automagically removing &quot;punctuation&quot; tokens (Default: ``False``)</span>
<span class="s2">    tree_class</span>
<span class="s2">            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.</span>

<span class="s2">    **=== Algorithm Options ===**</span>

<span class="s2">    parser</span>
<span class="s2">            Decides which parser engine to use. Accepts &quot;earley&quot; or &quot;lalr&quot;. (Default: &quot;earley&quot;).</span>
<span class="s2">            (there is also a &quot;cyk&quot; option for legacy)</span>
<span class="s2">    lexer</span>
<span class="s2">            Decides whether or not to use a lexer stage</span>

<span class="s2">            - &quot;auto&quot; (default): Choose for me based on the parser</span>
<span class="s2">            - &quot;basic&quot;: Use a basic lexer</span>
<span class="s2">            - &quot;contextual&quot;: Stronger lexer (only works with parser=&quot;lalr&quot;)</span>
<span class="s2">            - &quot;dynamic&quot;: Flexible and powerful (only with parser=&quot;earley&quot;)</span>
<span class="s2">            - &quot;dynamic_complete&quot;: Same as dynamic, but tries *every* variation of tokenizing possible.</span>
<span class="s2">    ambiguity</span>
<span class="s2">            Decides how to handle ambiguity in the parse. Only relevant if parser=&quot;earley&quot;</span>

<span class="s2">            - &quot;resolve&quot;: The parser will automatically choose the simplest derivation</span>
<span class="s2">              (it chooses consistently: greedy for tokens, non-greedy for rules)</span>
<span class="s2">            - &quot;explicit&quot;: The parser will return all derivations wrapped in &quot;_ambig&quot; tree nodes (i.e. a forest).</span>
<span class="s2">            - &quot;forest&quot;: The parser will return the root of the shared packed parse forest.</span>

<span class="s2">    **=== Misc. / Domain Specific Options ===**</span>

<span class="s2">    postlex</span>
<span class="s2">            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.</span>
<span class="s2">    priority</span>
<span class="s2">            How priorities should be evaluated - &quot;auto&quot;, ``None``, &quot;normal&quot;, &quot;invert&quot; (Default: &quot;auto&quot;)</span>
<span class="s2">    lexer_callbacks</span>
<span class="s2">            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.</span>
<span class="s2">    use_bytes</span>
<span class="s2">            Accept an input of type ``bytes`` instead of ``str``.</span>
<span class="s2">    edit_terminals</span>
<span class="s2">            A callback for editing the terminals before parse.</span>
<span class="s2">    import_paths</span>
<span class="s2">            A List of either paths or loader functions to specify from where grammars are imported</span>
<span class="s2">    source_path</span>
<span class="s2">            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading</span>
<span class="s2">    **=== End of Options ===**</span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="vm">__doc__</span><span class="p">:</span>
        <span class="vm">__doc__</span> <span class="o">+=</span> <span class="n">OPTIONS_DOC</span>


    <span class="c1"># Adding a new option needs to be done in multiple places:</span>
    <span class="c1"># - In the dictionary below. This is the primary truth of which options `Lark.__init__` accepts</span>
    <span class="c1"># - In the docstring above. It is used both for the docstring of `LarkOptions` and `Lark`, and in readthedocs</span>
    <span class="c1"># - As an attribute of `LarkOptions` above</span>
    <span class="c1"># - Potentially in `_LOAD_ALLOWED_OPTIONS` below this class, when the option doesn&#39;t change how the grammar is loaded</span>
    <span class="c1"># - Potentially in `lark.tools.__init__`, if it makes sense, and it can easily be passed as a cmd argument</span>
    <span class="n">_defaults</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;debug&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;keep_all_tokens&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;tree_class&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s1">&#39;cache&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;postlex&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s1">&#39;parser&#39;</span><span class="p">:</span> <span class="s1">&#39;earley&#39;</span><span class="p">,</span>
        <span class="s1">&#39;lexer&#39;</span><span class="p">:</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
        <span class="s1">&#39;transformer&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span>
        <span class="s1">&#39;priority&#39;</span><span class="p">:</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
        <span class="s1">&#39;ambiguity&#39;</span><span class="p">:</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
        <span class="s1">&#39;regex&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;propagate_positions&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;lexer_callbacks&#39;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s1">&#39;maybe_placeholders&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s1">&#39;edit_terminals&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s1">&#39;g_regex_flags&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;use_bytes&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;import_paths&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;source_path&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options_dict</span><span class="p">):</span>
        <span class="n">o</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">options_dict</span><span class="p">)</span>

        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">o</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;cache&#39;</span><span class="p">,</span> <span class="s1">&#39;use_bytes&#39;</span><span class="p">,</span> <span class="s1">&#39;propagate_positions&#39;</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">default</span>

            <span class="n">options</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">options</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]]</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span>


        <span class="n">assert_config</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;earley&#39;</span><span class="p">,</span> <span class="s1">&#39;lalr&#39;</span><span class="p">,</span> <span class="s1">&#39;cyk&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">==</span> <span class="s1">&#39;earley&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s1">&#39;Cannot specify an embedded transformer when using the Earley algorithm. &#39;</span>
                             <span class="s1">&#39;Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">o</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;Unknown options: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">o</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">assert_config</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> isn&#39;t a valid option. Expected one of: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="c1"># Options that can be passed to the Lark parser, even when it was loaded from cache/standalone.</span>
<span class="c1"># These option are only used outside of `load_grammar`.</span>
<span class="n">_LOAD_ALLOWED_OPTIONS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;postlex&#39;</span><span class="p">,</span> <span class="s1">&#39;transformer&#39;</span><span class="p">,</span> <span class="s1">&#39;lexer_callbacks&#39;</span><span class="p">,</span> <span class="s1">&#39;use_bytes&#39;</span><span class="p">,</span> <span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="s1">&#39;g_regex_flags&#39;</span><span class="p">,</span> <span class="s1">&#39;regex&#39;</span><span class="p">,</span> <span class="s1">&#39;propagate_positions&#39;</span><span class="p">,</span> <span class="s1">&#39;tree_class&#39;</span><span class="p">}</span>

<span class="n">_VALID_PRIORITY_OPTIONS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;invert&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">_VALID_AMBIGUITY_OPTIONS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;resolve&#39;</span><span class="p">,</span> <span class="s1">&#39;explicit&#39;</span><span class="p">,</span> <span class="s1">&#39;forest&#39;</span><span class="p">)</span>


<span class="n">_T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;_T&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Lark</span><span class="p">(</span><span class="n">Serialize</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main interface for the library.</span>

<span class="sd">    It&#39;s mostly a thin wrapper for the many different parsers, and for the tree constructor.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        grammar: a string or file-object containing the grammar spec (using Lark&#39;s ebnf syntax)</span>
<span class="sd">        options: a dictionary controlling various aspects of Lark.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; Lark(r&#39;&#39;&#39;start: &quot;foo&quot; &#39;&#39;&#39;)</span>
<span class="sd">        Lark(...)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source_path</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">source_grammar</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">grammar</span><span class="p">:</span> <span class="s1">&#39;Grammar&#39;</span>
    <span class="n">options</span><span class="p">:</span> <span class="n">LarkOptions</span>
    <span class="n">lexer</span><span class="p">:</span> <span class="n">Lexer</span>
    <span class="n">terminals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">TerminalDef</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="s1">&#39;Union[Grammar, str, IO[str]]&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">LarkOptions</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

        <span class="c1"># Set regex or re module</span>
        <span class="n">use_regex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">regex</span>
        <span class="k">if</span> <span class="n">use_regex</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">regex</span><span class="p">:</span>
                <span class="n">re_module</span> <span class="o">=</span> <span class="n">regex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;`regex` module must be installed if calling `Lark(regex=True)`.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">re_module</span> <span class="o">=</span> <span class="n">re</span>

        <span class="c1"># Some, but not all file-like objects have a &#39;name&#39; attribute</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">source_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">name</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span> <span class="o">=</span> <span class="s1">&#39;&lt;string&gt;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">source_path</span>

        <span class="c1"># Drain file-like objects to get their contents</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">read</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">read</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grammar</span> <span class="o">=</span> <span class="n">read</span><span class="p">()</span>

        <span class="n">cache_fn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cache_md5</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_bytes</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isascii</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;Grammar must be ascii only, when use_bytes=True&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span> <span class="o">!=</span> <span class="s1">&#39;lalr&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;cache only works with parser=&#39;lalr&#39; for now&quot;</span><span class="p">)</span>

                <span class="n">unhashable</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;transformer&#39;</span><span class="p">,</span> <span class="s1">&#39;postlex&#39;</span><span class="p">,</span> <span class="s1">&#39;lexer_callbacks&#39;</span><span class="p">,</span> <span class="s1">&#39;edit_terminals&#39;</span><span class="p">)</span>
                <span class="n">options_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">options</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unhashable</span><span class="p">)</span>
                <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">__version__</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">grammar</span> <span class="o">+</span> <span class="n">options_str</span> <span class="o">+</span> <span class="n">__version__</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">cache_md5</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">cache_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">cache</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;cache argument must be bool or str&quot;</span><span class="p">)</span>
                        
                    <span class="n">cache_fn</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;/.lark_cache_</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">.tmp&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cache_md5</span><span class="p">,</span> <span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">FS</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cache_fn</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Loading grammar from cache: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cache_fn</span><span class="p">)</span>
                    <span class="c1"># Remove options that aren&#39;t relevant for loading from cache</span>
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="o">-</span> <span class="n">_LOAD_ALLOWED_OPTIONS</span><span class="p">):</span>
                        <span class="k">del</span> <span class="n">options</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">with</span> <span class="n">FS</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">cache_fn</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">old_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">file_md5</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                            <span class="n">cached_used_files</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">file_md5</span> <span class="o">==</span> <span class="n">cache_md5</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">verify_used_files</span><span class="p">(</span><span class="n">cached_used_files</span><span class="p">):</span>
                                <span class="n">cached_parser_data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">(</span><span class="n">cached_parser_data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
                                <span class="k">return</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span> <span class="c1"># We should probably narrow done which errors we catch here.</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Failed to load Lark from cache: </span><span class="si">%r</span><span class="s2">. We will try to carry on.&quot;</span> <span class="o">%</span> <span class="n">cache_fn</span><span class="p">)</span>
                            
                            <span class="c1"># In theory, the Lark instance might have been messed up by the call to `_load`.</span>
                            <span class="c1"># In practice the only relevant thing that might have been overriden should be `options`</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">old_options</span>


            <span class="c1"># Parse the grammar file and compose the grammars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">,</span> <span class="n">used_files</span> <span class="o">=</span> <span class="n">load_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">import_paths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">keep_all_tokens</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">Grammar</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="n">grammar</span>


        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span> <span class="o">==</span> <span class="s1">&#39;lalr&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="s1">&#39;contextual&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span> <span class="o">==</span> <span class="s1">&#39;earley&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">postlex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;postlex can&#39;t be used with the dynamic lexer, so we use &#39;basic&#39; instead. &quot;</span>
                                <span class="s2">&quot;Consider using lalr with contextual instead of earley&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="s1">&#39;basic&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="s1">&#39;dynamic&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span> <span class="o">==</span> <span class="s1">&#39;cyk&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="s1">&#39;basic&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span>
        <span class="n">lexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">Lexer</span><span class="p">)</span>     <span class="c1"># XXX Is this really important? Maybe just ensure interface compliance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">assert_config</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;basic&#39;</span><span class="p">,</span> <span class="s1">&#39;contextual&#39;</span><span class="p">,</span> <span class="s1">&#39;dynamic&#39;</span><span class="p">,</span> <span class="s1">&#39;dynamic_complete&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">postlex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;dynamic&#39;</span> <span class="ow">in</span> <span class="n">lexer</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t use postlex with a dynamic lexer. Use basic or contextual instead&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">ambiguity</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span> <span class="o">==</span> <span class="s1">&#39;earley&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">ambiguity</span> <span class="o">=</span> <span class="s1">&#39;resolve&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">assert_config</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;earley&#39;</span><span class="p">,</span> <span class="s1">&#39;cyk&#39;</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> doesn&#39;t support disambiguation. Use one of these parsers instead: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_VALID_PRIORITY_OPTIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;invalid priority option: </span><span class="si">%r</span><span class="s2">. Must be one of </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span> <span class="n">_VALID_PRIORITY_OPTIONS</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">ambiguity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_VALID_AMBIGUITY_OPTIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;invalid ambiguity option: </span><span class="si">%r</span><span class="s2">. Must be one of </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">ambiguity</span><span class="p">,</span> <span class="n">_VALID_AMBIGUITY_OPTIONS</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">terminals_to_keep</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">postlex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">terminals_to_keep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">postlex</span><span class="o">.</span><span class="n">always_accept</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">terminals_to_keep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Compile the EBNF grammar into BNF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">terminals_to_keep</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">edit_terminals</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">edit_terminals</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_terminals_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">}</span>

        <span class="c1"># If the user asked to invert the priorities, negate them all here.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span> <span class="o">==</span> <span class="s1">&#39;invert&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rule</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">-</span><span class="n">rule</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">:</span>
                <span class="n">term</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">-</span><span class="n">term</span><span class="o">.</span><span class="n">priority</span>
        <span class="c1"># Else, if the user asked to disable priorities, strip them from the</span>
        <span class="c1"># rules and terminals. This allows the Earley parsers to skip an extra forest walk</span>
        <span class="c1"># for improved performance, if you don&#39;t need them (or didn&#39;t specify any).</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">rule</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">:</span>
                <span class="n">term</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># TODO Deprecate lexer_callbacks?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer_conf</span> <span class="o">=</span> <span class="n">LexerConf</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">,</span> <span class="n">re_module</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_tokens</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">postlex</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer_callbacks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">g_regex_flags</span><span class="p">,</span> <span class="n">use_bytes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">use_bytes</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_parser</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">lexer</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_lexer</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">cache_fn</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Saving grammar to cache: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">cache_fn</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">FS</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">cache_fn</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">cache_md5</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cache_md5</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">used_files</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">_LOAD_ALLOWED_OPTIONS</span><span class="p">)</span>

    <span class="k">if</span> <span class="vm">__doc__</span><span class="p">:</span>
        <span class="vm">__doc__</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">LarkOptions</span><span class="o">.</span><span class="n">OPTIONS_DOC</span>

    <span class="n">__serialize_fields__</span> <span class="o">=</span> <span class="s1">&#39;parser&#39;</span><span class="p">,</span> <span class="s1">&#39;rules&#39;</span><span class="p">,</span> <span class="s1">&#39;options&#39;</span>

    <span class="k">def</span> <span class="nf">_build_lexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dont_ignore</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">lexer_conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer_conf</span>
        <span class="k">if</span> <span class="n">dont_ignore</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
            <span class="n">lexer_conf</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">lexer_conf</span><span class="p">)</span>
            <span class="n">lexer_conf</span><span class="o">.</span><span class="n">ignore</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">return</span> <span class="n">BasicLexer</span><span class="p">(</span><span class="n">lexer_conf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># we don&#39;t need these callbacks if we aren&#39;t building a tree</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">ambiguity</span> <span class="o">!=</span> <span class="s1">&#39;forest&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_tree_builder</span> <span class="o">=</span> <span class="n">ParseTreeBuilder</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">tree_class</span> <span class="ow">or</span> <span class="n">Tree</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">propagate_positions</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span> <span class="o">!=</span> <span class="s1">&#39;lalr&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">ambiguity</span> <span class="o">==</span> <span class="s1">&#39;explicit&#39;</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">maybe_placeholders</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_tree_builder</span><span class="o">.</span><span class="n">create_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">transformer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_get_lexer_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">transformer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_build_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_callbacks</span><span class="p">()</span>
        <span class="n">parser_class</span> <span class="o">=</span> <span class="n">get_frontend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer</span><span class="p">)</span>
        <span class="n">parser_conf</span> <span class="o">=</span> <span class="n">ParserConf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rules</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parser_class</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lexer_conf</span><span class="p">,</span> <span class="n">parser_conf</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">exclude_options</span><span class="p">:</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Saves the instance into the given file object</span>

<span class="sd">        Useful for caching and multiprocessing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memo_serialize</span><span class="p">([</span><span class="n">TerminalDef</span><span class="p">,</span> <span class="n">Rule</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">exclude_options</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_options</span><span class="p">}</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">({</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="s1">&#39;memo&#39;</span><span class="p">:</span> <span class="n">m</span><span class="p">},</span> <span class="n">f</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads an instance from the given file object</span>

<span class="sd">        Useful for caching and multiprocessing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inst</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inst</span><span class="o">.</span><span class="n">_load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deserialize_lexer_conf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="n">lexer_conf</span> <span class="o">=</span> <span class="n">LexerConf</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;lexer_conf&#39;</span><span class="p">],</span> <span class="n">memo</span><span class="p">)</span>
        <span class="n">lexer_conf</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">lexer_callbacks</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">lexer_conf</span><span class="o">.</span><span class="n">re_module</span> <span class="o">=</span> <span class="n">regex</span> <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">regex</span> <span class="k">else</span> <span class="n">re</span>
        <span class="n">lexer_conf</span><span class="o">.</span><span class="n">use_bytes</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">use_bytes</span>
        <span class="n">lexer_conf</span><span class="o">.</span><span class="n">g_regex_flags</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">g_regex_flags</span>
        <span class="n">lexer_conf</span><span class="o">.</span><span class="n">skip_validation</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">lexer_conf</span><span class="o">.</span><span class="n">postlex</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">postlex</span>
        <span class="k">return</span> <span class="n">lexer_conf</span>

    <span class="k">def</span> <span class="nf">_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">memo_json</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;memo&#39;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>

        <span class="k">assert</span> <span class="n">memo_json</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="n">SerializeMemoizer</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">memo_json</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;Rule&#39;</span><span class="p">:</span> <span class="n">Rule</span><span class="p">,</span> <span class="s1">&#39;TerminalDef&#39;</span><span class="p">:</span> <span class="n">TerminalDef</span><span class="p">},</span> <span class="p">{})</span>
        <span class="n">options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="n">_LOAD_ALLOWED_OPTIONS</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">LarkOptions</span><span class="o">.</span><span class="n">_defaults</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;Some options are not allowed when loading a Parser: </span><span class="si">{}</span><span class="s2">&quot;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="n">_LOAD_ALLOWED_OPTIONS</span><span class="p">))</span>
        <span class="n">options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">LarkOptions</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rules</span> <span class="o">=</span> <span class="p">[</span><span class="n">Rule</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rules&#39;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_path</span> <span class="o">=</span> <span class="s1">&#39;&lt;deserialized&gt;&#39;</span>
        <span class="n">parser_class</span> <span class="o">=</span> <span class="n">get_frontend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer_conf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deserialize_lexer_conf</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;parser&#39;</span><span class="p">],</span> <span class="n">memo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer_conf</span><span class="o">.</span><span class="n">terminals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_callbacks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_terminals_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser_class</span><span class="o">.</span><span class="n">deserialize</span><span class="p">(</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;parser&#39;</span><span class="p">],</span>
            <span class="n">memo</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lexer_conf</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span>  <span class="c1"># Not all, but multiple attributes are used</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_load_from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">inst</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inst</span><span class="o">.</span><span class="n">_load</span><span class="p">({</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="s1">&#39;memo&#39;</span><span class="p">:</span> <span class="n">memo</span><span class="p">},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">_T</span><span class="p">],</span> <span class="n">grammar_filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rel_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_T</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of Lark with the grammar given by its filename</span>

<span class="sd">        If ``rel_to`` is provided, the function will find the grammar filename in relation to it.</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; Lark.open(&quot;grammar_file.lark&quot;, rel_to=__file__, parser=&quot;lalr&quot;)</span>
<span class="sd">            Lark(...)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rel_to</span><span class="p">:</span>
            <span class="n">basepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">rel_to</span><span class="p">)</span>
            <span class="n">grammar_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">basepath</span><span class="p">,</span> <span class="n">grammar_filename</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">grammar_filename</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">open_from_package</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">_T</span><span class="p">],</span> <span class="n">package</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">grammar_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">search_paths</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,),</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_T</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create an instance of Lark with the grammar loaded from within the package `package`.</span>
<span class="sd">        This allows grammar loading from zipapps.</span>

<span class="sd">        Imports in the grammar will use the `package` and `search_paths` provided, through `FromPackageLoader`</span>

<span class="sd">        Example:</span>

<span class="sd">            Lark.open_from_package(__name__, &quot;example.lark&quot;, (&quot;grammars&quot;,), parser=...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">package_loader</span> <span class="o">=</span> <span class="n">FromPackageLoader</span><span class="p">(</span><span class="n">package</span><span class="p">,</span> <span class="n">search_paths</span><span class="p">)</span>
        <span class="n">full_path</span><span class="p">,</span> <span class="n">text</span> <span class="o">=</span> <span class="n">package_loader</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">grammar_path</span><span class="p">)</span>
        <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;source_path&#39;</span><span class="p">,</span> <span class="n">full_path</span><span class="p">)</span>
        <span class="n">options</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;import_paths&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;import_paths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">package_loader</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Lark(open(</span><span class="si">%r</span><span class="s1">), parser=</span><span class="si">%r</span><span class="s1">, lexer=</span><span class="si">%r</span><span class="s1">, ...)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">lexer</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">lex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dont_ignore</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Token</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Only lex (and postlex) the text, without parsing it. Only relevant when lexer=&#39;basic&#39;</span>

<span class="sd">        When dont_ignore=True, the lexer will return all tokens, even those marked for %ignore.</span>

<span class="sd">        :raises UnexpectedCharacters: In case the lexer cannot find a suitable match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;lexer&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dont_ignore</span><span class="p">:</span>
            <span class="n">lexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_lexer</span><span class="p">(</span><span class="n">dont_ignore</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span>
        <span class="n">lexer_thread</span> <span class="o">=</span> <span class="n">LexerThread</span><span class="p">(</span><span class="n">lexer</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">lexer_thread</span><span class="o">.</span><span class="n">lex</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">postlex</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">postlex</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stream</span>

    <span class="k">def</span> <span class="nf">get_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TerminalDef</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get information about a terminal&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_terminals_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">parse_interactive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;InteractiveParser&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Start an interactive parsing session.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            text (str, optional): Text to be parsed. Required for ``resume_parse()``.</span>
<span class="sd">            start (str, optional): Start symbol</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new InteractiveParser instance.</span>

<span class="sd">        See Also: ``Lark.parse()``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse_interactive</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">on_error</span><span class="p">:</span> <span class="s1">&#39;Optional[Callable[[UnexpectedInput], bool]]&#39;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tree</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Parse the given text, according to the options provided.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            text (str): Text to be parsed.</span>
<span class="sd">            start (str, optional): Required if Lark was given multiple possible start symbols (using the start option).</span>
<span class="sd">            on_error (function, optional): if provided, will be called on UnexpectedToken error. Return true to resume parsing.</span>
<span class="sd">                LALR only. See examples/advanced/error_handling.py for an example of how to use on_error.</span>

<span class="sd">        Returns:</span>
<span class="sd">            If a transformer is supplied to ``__init__``, returns whatever is the</span>
<span class="sd">            result of the transformation. Otherwise, returns a Tree instance.</span>

<span class="sd">        :raises UnexpectedInput: On a parse error, one of these sub-exceptions will rise:</span>
<span class="sd">                ``UnexpectedCharacters``, ``UnexpectedToken``, or ``UnexpectedEOF``.</span>
<span class="sd">                For convenience, these sub-exceptions also inherit from ``ParserError`` and ``LexerError``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">on_error</span><span class="o">=</span><span class="n">on_error</span><span class="p">)</span>


<span class="c1">###}</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">samoyed  文档</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >模块代码</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">lark.lark</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 2021, ruiqurm.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.1.
    </div>
  </body>
</html>